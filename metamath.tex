\chapter{Metamathematical remarks}
\label{app:metamath}

[TODO: Give precise rules for our type theory and discuss some syntactic matters:
definitional equality, more precision around normalization and canonicity, etc.]

The statement that something is not provable is a statement \emph{about},
and not \emph{in}, a theory. Proving such a statement often requires
properties of the theory that cannot be formulated nor proved in the theory itself.

One such `metaproperty' that we use here is \emph{canonicity}.
We call an element \emph{closed} if it does not contain free variables.
An example of canonicity is that every closed natural number is a \emph{numeral},
that is, either $0$ or $S(n)$ for some numeral $n$.
Another example of canonicity is that every closed element of $L\coprod R$
is either of the form $\inl{l}$ for some $l:L$ or
of the form $\inr{r}$ for some $r:R$.
A second important metaproperty of our theory is that one can compute canonical forms.

[TODO: Write more about what metamathematics is.]

\section{Definitional equality}
\label{sec:defeq}

\subsection{Basics}
\label{sec:defeq-basics}

The concept of definition was introduced in \cref{univalent-mathematics},
together with what it means to be \emph{the same by definition}. 
Being the same by definition, or being definitionally equal, 
(NB appears for the first time on p. 26!) 
is a relationship between syntactic expressions.
In this section we provide more details about this relationship.

There are four basic forms of definitional equality:
\begin{enumerate}
\item The original form: making an explicit definition, e.g., $1 \defeq \Succ(0)$;%
\footnote{The notation $\defeq$ serves two purposes: 
(1) the ``:'' tells the reader that we make a definition
(or reminds the reader that this definition has been made);
(2) we state that the definitional equality $1 \jdeq \Succ(0)$ holds.}
\item The extension of the original form as found in inductive definitions,
e.g., $n+0 \defeq n$ and $n+\Succ(m) \defeq \Succ(n+m)$;
\item Simplifying the application of an explicitly defined function to an argument,
e.g., $(x \mapsto f(x))(a) \jdeq f(a)$;
\item Simplifying the explicit definition of a function that is already given,
e.g., $(x \mapsto S(x)) \jdeq S$;
\end{enumerate}

Definitional equality is the \emph{congruence closure} of these 
four basic forms, that is, the smallest reflexive, symmetric, transitive
and congruent relation that contains all instances of the four basic forms.
Here a congruent relation is a relation that is closed under all syntactic
operations of type theory. For example, if $T : \NN\to\UU$, then $T(n)\jdeq T(n+0)$
using symmetry and congruence, and for any $P: T(n)\to\UU$ we have
$\prod_{x:T(n)} P(x) \jdeq \prod_{x:T(n+0)} P(x)$ by another application
of congruence.

%Discuss later: If syntactic expressions $e$ and $e'$ are definitionally equal, denoted by $e\jdeq e'$, then $e$ and $e'$ have the same type $T$, then $\refl e : e=_T e'$; the converse is not true.

\subsection{Testing definitional equality}
\label{sec:defeq-computation}

By a \emph{test} we mean here a terminating algorithmic procedure that 
answers a yes/no question.
Although it is possible to enumerate all true definitional equalities,
this does not give a test that answers whether or not a given instance $e\jdeq e'$ holds.
In particular when $e\jdeq e'$ does not hold, such an enumeration will not terminate.
A test of definitional equality is important for type checking,
as the examples in the last paragraph of the previous section show.

A better approach to a test of definitional equality is the following.
First direct the four basic forms of definitional equality from left to right
as they are given.\footnote{%
TODO: think about the last, $\eta$.}
For the first two forms this can be viewed as unfolding definitions,
and for the last two forms as simplifying function application and (unnecessary) 
abstraction, respectively.
This defines a basic reduction relation, and we write $e\to e'$ if $e'$ can
be obtained by a basic reduction of a subexpression in $e$. 
The reflexive transitive closure of $\to$ is denoted by $\to^*$.
The symmetric closure of $\to^*$ coincides with $\jdeq$.

We mention a few important properties of the relations $\to,\to^*$ and $\jdeq$.
The first is called the Church-Rosser property, and states that,
if $e\jdeq e'$, then there is an expression $c$ such that $e\to^* c$
and $e'\to^* c$. The second is called type safety and states that,
if $e:T$ and $e\to e'$, then also $e':T$.
The third is called termination and states that for well-typed expressions $e$
there is no infinite reduction sequence starting with $e$.
The proofs of Church-Rosser and type safety are long and tedious, but pose no essential
difficulties. For a non-trivial type theory such as in this book the last property,
termination, is extremely difficult and has not been carried out in full detail.
The closest come results on the Coq \footcite{Coq} (TODO: find good reference).

Testing definitional equality of given well-typed terms $e$ and $e'$ can now be done
by reducing them with $\to$ until one reaches irreducible expressions $n$ and $n'$
such that $e\to^* n$ and $e'\to^* n'$, and then comparing $n$ and $n'$. 
Now we have: $e\jdeq e'$ iff $n\jdeq n'$ iff (by Church-Rosser)
there exists a $c$ such that $n\to^* c$ and $n'\to^* c$.
Since $n$ and $n'$ are irreducible the latter is equivalent to
$n$ and $n'$ being identical syntactic expressions.

\section{The Limited Principle of Omniscience}
\label{sec:LPO}

\begin{remark}\label{rem:LPO-solves-halting problem}
Recall the Limited Principle of Omniscience (LPO), \cref{LPO}:
  for any function $P:\NN\to\bn 2$,
  either there is a smallest number $n_0:\NN$ such that $P(n_0)=1$,
  or $P$ is a constant function with value $0$.
We will show that LPO is not provable in our theory.

The argument is based on the halting problem: given a Turing machine
$M$ and an input $n$, determine whether $M$ halts on $n$.
It is known that the halting problem cannot be solved by an algorithm
that can be implemented on a Turing machine.\footnote{It's commonly accepted that
  every algorithm \emph{can} be thus implemented.}

We use a few more facts from computability theory.
First, Turing machines can be enumerated. We denote the $n$\th Turing machine $M_n$,
so we can list the Turing machines in order: $M_0,M_1,\ldots$.
Secondly, there exists a function $T(e,n,k)$ such that $T(e,n,k) = 1$
if $M_e$ halts on input $n$ in at most $k$ steps, and $T(e,n,k) = 0$
otherwise. This function $T$ can be implemented in our theory.

Towards a contradiction, assume we have a closed proof $t$ of LPO in our theory.
We assume as well that $t$ does not depend on any axiom.\footnote{It is possible to weaken the notion
  of canonicity so that the argument still works even if the proof $t$ uses the Univalence Axiom.
Of course, the argument must fail if we allow $t$ to use LEM!}
It is clear that $k\mapsto T(e,n,k)$ is a constant function with value $0$
if and only if $M_e$ does not halt on input $n$. Now consider $t(k\mapsto T(e,n,k))$,
which is an element of a type of the form $L\coprod R$.

We now explain how to solve the halting problem.
Let $e$ and $n$ be arbitrary numerals.
Then $t(k\mapsto T(e,n,k))$ is a closed element of $L\coprod R$.
Hence we can compute its canonical form. If $t(k\mapsto T(e,n,k))\jdeq\inr{r}$ for some
$r:R$, then $k\mapsto T(e,n,k)$ is a constant function with value $0$,
and $M_e$ does not halt on input $n$. If $t(k\mapsto T(e,n,k))\jdeq\inl{l}$ for some
$l:L$, then $M_e$ does halt on input $n$.
Thus we have an algorithm to solve the halting problem
for all $e$ and $n$. Since this is impossible, we have refuted the assumption
that there is a closed proof $t$ of LPO in our theory.
\end{remark}

%%% Local Variables:
%%% mode: latex
%%% fill-column: 144
%%% latex-block-names: ("lemma" "theorem" "remark" "definition" "corollary" "fact" "properties" "conjecture" "proof" "question" "proposition")
%%% TeX-master: "book"
%%% End:
